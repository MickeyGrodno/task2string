class Parent {   public int getValue() {      return 5;   }}class Child extends Parent {   // Переопределение метода   public int getValue() {     return 3;   }   public static void main(String s[]) {     Child c = new Child();     // пример вызова переопределенного метода     System.out.println(c.getValue());   }}
Вызов переопределенного метода использует механизм полиморфизма, который подробно рассматривается в конце этой лекции. Однако ясно, что результатом выполнения примера будет значение 3. Невозможно, используя ссылку типа Child, получить из метода getValue()  значение 5, родительский метод перекрыт и уже недоступен.

Иногда при переопределении  бывает полезно воспользоваться результатом работы родительского метода. Предположим, он делал сложные вычисления, а переопределенный метод должен вернуть округленный результат этих вычислений. Понятно, что гораздо удобнее обратиться к родительскому методу, чем заново описывать весь алгоритм. Здесь применяется слово super. Из класса наследника с его помощью можно обращаться к переопределенным методам родителя:

class Parent {   public int getValue() {      return 5;   }}class Child extends Parent {   // переопределение метода   public int getValue() {      // обращение к методу родителя      return super.getValue()+1;   }   public static void main(String s[]) {      Child c = new Child();      System.out.println(c.getValue());   }}
Результатом работы программы будет значение 6.

Обращаться с помощью ключевого слова super  к переопределенному методу родителя, т.е. на два уровня наследования вверх, невозможно. Если родительский класс переопределил функциональность своего родителя, значит, она не будет доступна его наследникам.
